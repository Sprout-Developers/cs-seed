JAVA MEMORY MODEL
==================   

자바 메모리 모델은 컴퓨터의 메모리를(RAM)을 통해 JVM이 어떻게 작동되는지 보여준다.            
JVM은 그 자체로 하나의 컴퓨터 모델이기 때문에 내부적으로 메모리 모델을 포함한다.      
  
올바르게 동작하는 동시성 프로그램을 설계하려면  자바 메모리 모델을 이해하는 것이 매우 중요하다.    
멀티 스레드간 공용으로 사용하는 공유 변수에 쓴 값을 볼 수 있는 방법과 시기를 지정하고              
필요할 때 공유 변수에 대한 액세스를 동기화하는 방법을 지정할 수 있기 때문이다.                 

# 자바 메모리 모델 내부 
    
JVM에서 내부적으로 사용되는 자바 메모리 모델은 메모리를 쓰레드 스택(들)과 힙(heap)으로 나눈다.       
      
![jvm memory](https://user-images.githubusercontent.com/50267433/132948647-0fdfc04c-ba32-474c-a106-5238df567662.png)
          
JVM에서 실행되는 **각 쓰레드에는 고유한 쓰레드 스택이 있다.**            
쓰레드 스택에는 **쓰레드가 현호출한 메소드들의 현재 실행되는 지점(코드)을 보여주기 위한 정보가 들어있다.**             
이러한 정보를 `Call Stack`이라고 부르며 이 `Call Stack`은 쓰레드가 코드를 실행함에 따라 변화한다.     
          
쓰레드 스택은 지역 변수와 같은 쓰레드가 실행하는 메서드의 데이터를 가지고 있다.                  
그리고 자신의 쓰레드만 접근할 수 있기에 Thread Safe 하다는 특징을 가지고 있다.           
     
즉, 이러한 특징으로 여러 쓰레드가 완벽히 동일한 데이터(공유된 데이터)를 활용한다고 하더라도            
처음에는 Main Memory에서 값을 가져 오지만 이후에는 각자의 쓰레드 스택에 있는 CPU Cache 를 활용한다.                  

![jvm memory data](https://user-images.githubusercontent.com/50267433/132972485-862559d3-3a32-4aeb-819f-ad72786e4715.png)  
       
쓰레드 스택에는 모든 기본형 타입 지역 변수의 데이터가 저장되며, 변수를 저장한 쓰레드만 접근할 수 있다.        
쓰레드는 기본형 변수의 **복사본을 다른 쓰레드에게 전달할 수 있지만, 원본을 공유하는 일은 불가능하다.**           
                      
힙에는 자바 어플리케이션이 생성한 모든 객체들이 들어있다.                
**어떤 객체가 어떤 쓰레드에 의해 생성되었는가는 아무런 상관이 없으며 오로지 객체의 존재 여부만을 바라본다.**          
즉, 지역변수로 객체가 할당되었든, 아니면 다른 객체의 멤버 변수로 할당되었든, 객체는 여전히 힙에 저장된다.   
참고로 기본형 타입의 객체(Byte, Integer, Long 기타 등등)도 포함된다.        
                     
위 그림을 통해 한가지 알 수 있는 점은 **메서드의 지역 변수는 쓰레드 스택에 저장된다.**                
즉, **primitve 타입 지역 변수는 물론 reference 타입 지역 변수는 쓰레드 스택에 저장된다는 말이다.**                   
이유는 간단하게도 메서드가 종료됨과 동시에 쓰레드 스택을 비우는 과정이 일어나는데          
이 과정에서 힙이나 클래스 영역에 데이터가 존재한다면 다 찾아야하고 누락되는 문제가 발생할 수 있기 때문이다.           
         
하지만 반대로 객체와 밀접한 **인스턴스 변수들은 힙에 저장되고 있는 것을 알 수 있다.**      
이들은 객체의 생명주기를 그대로 따르기 때문에 primitve 타입이든 reference 타입이든 상관없이 객체와 함께 힙에 저장된다.     
참고로, 스태틱 클래스 변수 또한 클래스 정의와 함께 힙에 저장된다.        
    
![jvm memory reference](https://user-images.githubusercontent.com/50267433/132973022-90d5abd0-b873-4ebf-9cf0-eb744ab3d61e.png)    
                
객체는 참조를 지닌 모든 쓰레드들이 접근 가능하다.              
한 쓰레드가 어떤 객체로 접근할 때, 이 쓰레드는 객체와 함께 객체 내부에 지닌 멤버 변수로의 접근 또한 가능하다.                     
즉, 동일한 객체를 기준으로 서로 다른 쓰레드에서 공유하면서 접근할 수 있다는 것을 의미한다.   
              
**하지만 만일 두 쓰레드가 `동시에` 같은 객체 및 멤버 변수에 접근한다면? 🤔**             
각 쓰레드는 **자신의 쓰레드 스택에 지역변 수로 이 객체의 본사본을 가지게 된다.**        

**Runnable**
```java
public class MyRunnable implements Runnable() {

    public void run() {
        methodOne();
    }

    public void methodOne() {
        int localVariable1 = 45;

        MySharedObject localVariable2 = MySharedObject.sharedInstance;  // 지역 참조 변수 고유 쓰레드 스택에 저장 

        //... do more with local variables.

        methodTwo();
    }

    public void methodTwo() {
        Integer localVariable1 = new Integer(99);                       // 지역 참조 변수 고유 쓰레드 스택에 저장 

        //... do more with local variable.
    }
}
```  
**SharedObject**
```java
public class MySharedObject {

    //static variable pointing to instance of MySharedObject
    
    public static final MySharedObject sharedInstance = new MySharedObject();      

    //member variables pointing to two objects on the heap

    public Integer object2 = new Integer(22);                           // 인스턴스 변수이므로 힙에 저장
    public Integer object4 = new Integer(44);

    public long member1 = 12345;                                        // 인스턴스 변수이므로 힙에 저장 
    public long member1 = 67890;
    
}
```
   
# 하드웨어 메모리 아키텍처  
현대의 컴퓨터는 2개 이상의 CPU 가 탑제되어 있고 이런 CPU는 멀티코어로 작동하기도 한다.          
이는 곧 2개 이상의 쓰레드를 동시에 돌릴 수 있다는 것이고 이는 멀티 쓰레드 지원 환경에서 매우 유용하다.            
   
 ![hardware memory architecture](https://user-images.githubusercontent.com/50267433/132973666-0eb54270-9eea-451b-ac79-6e7a3a8f0e02.png)
              
CPU는 CPU 메모리에 기본적으로 존재하는 레지스터들을 포함하고 있다.           
CPU는 이 **레지스터들을 통해 메인 메모리 안의 데이터를 작업할 때보다 훨씬 빠른 속도로 명령을 수행할 수 있다.**         
이것이 가능한 이유는 CPU가 레지스터에 접근하는 속도가 메인 메모리에 접근하는 속도보다 훨씬 빠른 데에 있다.         
                           
CPU는 또한 캐시 메모리 영역을 가지고 있는데, 캐시 메모리 영역을 통해서도 명령을 수행하는 일을 한다.   
단, 메인 메모리에 접근하는 속도보다 훨씬 빠르지만 레지스터만큼 빠르지는 않다.     
     
컴퓨터는 메인 메모리 영역(RAM)을 가지고 있다.        
모든 CPU는 이 메인 메모리에 접근 가능하며, 일반적으로 이 메모리 영역은 CPU 의 캐시 메모리보다 훨씬 크다.      
   
* 크기 : 레지스터 < 캐시 < 메모리  
* 속도 : 레지스터 > 캐시 > 메모리    

## Read & Write Process
### Read     
CPU가 메인 메모리로의 접근을 필요로 할 때, 아래와 같은 작업을 수행한다.      
   
1. CPU는 메인 메모리의 일부분을 CPU 캐시로 읽어들인다(RAM -> Cache).      
2. 이 캐시의 일부분을 자신의 내부 레지스터로 다시 읽어들인다.(Cache -> CPU Registers)
3. 읽어들인 데이터로 명령을 수행한다.    
     
### write     
데이터를 다시 메인 메모리에 저장(writing)하기 위해서는 데이터를 읽어들일 때의 과정을 역순으로 밟는다.    
즉, 작업 결과를 레지스터에서 캐시로 보내고, 적절한 시점에 캐시에서 메인 메모리로 보낸다.   
         
1. 명령 수행 결과를 내부 레지스터에 저장한다.       
2. 내부 레지스터의 값을 캐시에 저장한다.        
3. 캐시에 저장된 값을 메인 메모리에 저장한다.       

참고로 **⭐ 캐시가 데이터를 메인 메모리로 보내는 적절한 시점이란, CPU가 캐시 메모리에 `달라진 데이터`를 저장해야 할 때이다.**         
            
CPU 캐시는 자신의 메모리에 데이터를 한 번 저장할 때, 메모리의 일부에 데이터를 저장해둘 수 있고, 또 일부분만을 보내는 일도 가능하다.     
즉 캐시가 데이터를 읽거나 쓸 때, 반드시 한번에 캐시 메모리의 모든 데이터를 처리하지 않아도 된다는 말이다.          
또한 이는 곧, CPU Cache 독자적으로 변경이 된 데이터만 메인 메모리에 보내서 갱신을 할 수 있다는 의미이기도 하다.       
                   
이 같은 동작이 가능한 것은 캐시는 '캐시 라인(cache lines)' 이라고 불리는 작은 메모리 블록에 데이터를 갱신하기 때문이다.            
캐시 메모리에는 한 줄 이상의 캐시 라인을 읽어들일 수 있고, 반대로 한 줄 이상의 캐시 라인을 메인 메모리로 보낼(저장할) 수도 있다.         

# 자바 메모리 모델과 하드웨어 메모리 아키텍처의 연결   
자바 메모리 모델과 하드웨어 메모리 아키텍처에는 차이가 있다.            
      
![java memeory model with hardware](https://user-images.githubusercontent.com/50267433/132974123-caf5c5fd-747d-49d8-b74f-6810dda797b9.png)    
            
하드웨어 메모리 아키텍처는 쓰레드 스택과 힙을 구분하지 않는다.            
하드웨어에서 **쓰레드 스택과 힙은 모두 메인 메모리에 위치한다.**          
그리고 쓰레드 스택과 힙의 일부분은 종종 CPU 캐시와 CPU 레지스터에도 나타날 수 있다.    

이렇듯 객체와 변수들은 컴퓨터의 다양한 메모리 영역에 존재할 수 있다.   
그러나 여기서 여러 문제들이 발생할 수 있는데 대표적으로 2가지 문제점에 대해서 다루고자 한다.    
        
1. 공유 변수에 대한 쓰레드 업데이트(쓰기 작업)의 가시성(visibility)  
2. 공유 변수에의 읽기, 확인(checking), 쓰기(writing) 작업의 경합 조건     
   
## 공유 객체의 가시성(visibility)  
둘 이상의 쓰레드가 `volatile`이나 `synchronization`을 사용하지 않은 상태로 **한 객체를 공유한다면,**         
이 공유 객체로의 업데이트 작업은 **다른 쓰레드들에게는 변경이 보이지 않는 상황(업데이트 안됨)이 발생할 수 있다.**          

![miss match](https://user-images.githubusercontent.com/50267433/132974603-77795353-1c1f-4444-a872-233ee4c041e6.png)    

한 CPU에서 실행되는 한 쓰레드가 공유 객체를 CPU 캐시로 읽어들이고 객체의 어떤 값을 변경했다고 가정한다.          
이 CPU 캐시(쓰레드)가 변경된 객체 정보를 메인 메모리로 보내지 않는 한, 공유 객체의 변경된 정보는 다른 CPU에서 실행되는 쓰레드는 볼 수 없다.          
나머지 CPU는 자신들의 캐시에 변경 되기 이전의 공유 객체의 값을 가지고 있으므로 데이터들간의 일관성(가시성)이 깨지게 된다.            
       
## 경합 조건(Race Condition)       
둘 이상의 쓰레드가 한 객체를 공유하는 상황에서 **한 쓰레드가 공유 객체의 변수값을 변경했을 때 `경합 조건`이 발생할 수 있다.**    
     
![miss match](https://user-images.githubusercontent.com/50267433/132974603-77795353-1c1f-4444-a872-233ee4c041e6.png)    
    
* 공유 객체가 존재하는 1이라는 값을 가진 변수 count가 존재한다.    
* 한 CPU에서 실행되는 쓰레드 A 가 `공유 객체의 변수인 count`를 자신의 캐시에 읽어들였다. 
* 다른 CPU에서 실행되는 쓰레드 B 역시 `공유 객체의 변수인 count`를 자신의 캐시에 읽어들였다.   
* **동시에** `쓰레드 A`와 `쓰레드 B`는 변수값에 1을 더하는 작업을 수행했다.     
           
원칙적으로 "1 더하기"를 2번 진행했으므로 원래값은 **기존에 비해 2가 증가 된 3이 되어야 하는게 정상이다.**         
그러나 이 두 번의 작업은 각각의 쓰레드에서 **동시에 수행되었다.** 는 점을 유념하길 바란다.    
                       
`쓰레드 A/B`는 메인 메모리에서 `1`이라는 데이터를 읽고 `CPU Cache`에 저장을 한다.                
그리고 각각의 쓰레드들은 앞으로의 작업들을 각 쓰레드의 `CPU Cache`를 바라보면서 진행할 것이다.         
즉, **1 이라는 데이터를 저장한 CPU Cache만을 바라보면서 작업하게 되면서 3이 아닌 2라는 값을 가지게 된다.**         
이후 쓰기에서 3이란느 값을 저장해야하는데 2라는 값을 저장하는 불상사도 발생시킨다.       
     
## 문제 해결하기     
이 같은 문제들을 해결하는 방법은 크게 3가지가 있다.     
    
1. synchronized 
2. volatile
3. atomic 

이와 관련된 내용은 다른 MD 문서에 정리했으니 이를 확인 바란다.   
다만, 이들과 관련하여 생각해볼 점이 있어 따로 글을 남겨본다.     
    
`volaile`을 이용하면 메인 메모리에서 값을 읽어오기 때문에 읽고 쓰는데 큰 문제가 없다.       
`atomic`을 이용하면 CPU Cache 와 메모리의 값이 다른 것을 판단하여 갱신하는 작업을 한다.     
                    
그런데 `synchronized` 같은 경우 `lock`만 걸어 원자적 연산을 수행하도록 도와주는 것이기에                
마찬가지로 한쪽 쓰레드가 값을 변경하면 다른 쓰레드들은 갱신되지 않아야 된다고 생각이 든다.        
그러나 사실은 `synchronized` 같은 경우 `원자적 연산 수행`은 물론 데이터를 갱신하는 역할도 한다.      

